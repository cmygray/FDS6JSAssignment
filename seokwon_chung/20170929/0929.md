복습
생성자함수에서 나온 인스턴스는 생성자함수의 프로타타입을 프로토타입 객체라 부른다.ECMA 스크립트에서는 [[prototype]]으로 본다. 크롬에서는 인스턴스 console.dir을 찍어보면 __proto__로 확인할 수 있다. 브라우저마다 
이를 표시하는 방법이 다르다.

만들어질 예정인 인스턴스의 프로퍼티를 수정하고 싶다면 생성자 함수의 프로토타입을 건드려야함.

함수로 보면, 특정 함수의 생성자 함수는 Function생성자 함수고 특정 함수의 프로토타입은 Function.prototype이다.

인스턴스가 자신의 생성자를 알고 싶으면 
인스턴스명.constructor를 입력하면 알 수 있다. 프로퍼티 컨스트럭터는 인스턴스에 없고 프로토타입에 위치해있다.  

인스턴스도 객체이므로 프로퍼티 프로토타입을 가지고 있다. 하지만 인스턴스로 인스턴스의 인스턴스를 만들 확률은 적으므로 사용빈도는 낮다.

##즉시실행함수
저장이 되지 않고 즉시 실행이 된다. 보통 어플리케이션 기본 설정을 읽을 때 사용한다. 또한 전역변수의 위험을 낮추려고 즉시실행함수를 이용할 떄가 있는데 이는 괄호 안에 있는 모든 코드가 지역 전역변수로 지정되고 바로 실행하려는 목적에 있다.

##콜백함수
자신을 매개로 혹은 리턴값으로 갖는 함수. 기본적으로 브라우저의 동작에 따라 자동으로 실행되도록 설계됨.(인터넷 사용자의 클릭이나 시간에 따라)

##변수의 프로토타입
var a = {
	name : "dd",
	age : "12"
}

a.hasOwnProperty('name'); //true
인스턴스a가 프로토타입을 참조했기에 위의 메소드가 가능함. 콘솔 dir을 찍어보면 a의 프로토타입이 오브젝트로 적혀있는 것을 알 수 있다. 왜냐하면 a생성자는 오브젝트기 때문.

f Object { }            Object.prototype
                          hasOwnProperty

                                Student
                            name / score

Object.prototype.__proto__ // null
프로토타입이 종점

##프로토타입 체인의 관점에서 객체리터럴의 의미
객체리터럴은 생성자함수(object.prototpye이 아니라 함수.prototype)를 생성하지 않는다는 것을 전제한다. 그래서 만약 객체리터럴에 동적인 추가를 하고 싶은 경우 object.prototype에 넣어야 하는데, 이런 행동은 오브젝트 아래 모든 객체에 불필요한 메소드를 추가한다는 뜻이므로(더군다나 object.prototype엔 메소드를 추가하는 게 적절치 않다). 만약 동적 추가를 고려해야한다면 객체리터럴보다 생성자함수를 사용하는 것이 적절하다. 


##기본자료형의 확장 - 기본자료형도 객체가 된다.
기본자료형이 들어간 변수에 점(.)을 찍는 순간 자바스크립트 엔진은 기본자료형을 객체로 인식하고 실행이 완료되면 다시 기본자료형으로 변환한다.

자바스크립트는 문자열 객체, 넘버 객체 등 기본자료형을 객체로 만들어주는 객체가 있다.(new String, new Number 등..) 
그래서 이들 객체의 프로토타입에 커스텀 메소드를 넣어서 기본자료형에도 공통된 메소도를 적용시키는 방법이 있는데 이는 추천하는 방법이 아니다.

##객체지향을 목적으로 프로토타입 자체를 갈아끼우는 방법
ES5시절 자바스크립트에 없는 클래스의 개념을 도입시켜 객체지향 프로그래밍을 하고 싶었던 사람들이 프로토타입을 모듈처럼 갈아끼워서 쓴다는 개념을 도입했다. 하지만 이 방법은 컨스트럭터가 없는 등 여러 부작용을 내포하고 있다. 특정 객체 프로토타입에 새로운 객체로 덮어쓰기를 하면 기존에 있던 프로퍼티가 모두 사라져서 프로토타입의 컨스트럭터를 수동으로 지정해줘야한다.

##블록 레벨 스코프/함수 레벨 스코프
자바스크립트에서는 for문이 들여쓰기 없이 생성했을 때
그 조건문에 있는 변수는 전역의 범위를 띄며 for문 블락이 넘어서도
변수로서 기능하기 때문에 메모리를 많이 잡아 먹는다.

그러면 전역/지역 왜 이런 걸 만들었을까? 똑같은 변수명을 다른 맥락에서 활용할 수 있기 때문에. 또 지역 변수는 함수 실행이 끝나고 메모리에서 제외시켜도 된다.

##자바스크립트 구동 환경마다 전역 객체가 다르다.
브라우저에 내장된 최상위 객체는 window,
노드에 내장된 최상위 객체는 global.

/* 노드 환경 */
var x = "global";
console.log(x); // x
console.log(window.x); // ReferenceError 


##this
arguments랑 기본적으로 생성되는 widow의 프로퍼티. new 생성자로
만드는 순간 this가 가리키는 건 인스턴스(생성자가 생성할 객체).
일반함수 // 원칙적으로 window 즉, 전역객체를 가리킴.

단, 콜백함수 일 때는 window
메소드의 주인이 this
== 다른 프로퍼티 명(데이터)을 가지지만 같은 메소드를 활용할 때
생성자일 때
== 생성자가 만들 객체

##this 정리 
내부함수 this window
일반함수 this는 window(전역객체)
콜백 this window
함수선언식 this window
함수표현식 this window

메서드의 this는 소유주
생성자함수의 this는 생성자함수가 생성할 인스턴스(객체)

##apply호출 패턴
객체 프로토타입에 내장된 함수. this로 사용할 객체와 그 객체가 가리키는 this가 가진 프로퍼티에 들어갈 값을 인자로 갖는다.(예제 참고)
this를 지정할 수 있는 또 다른 방법 중 하나.

##slice
var arr = Array.prototype.slice.apply(arguments)
Array Array.prototpye
            slice메소드
            
-> slice 메소드는 array 객체의 프로퍼티다. 만약 array객체가 아닌 객체가 slice를 쓰고 싶으면 slice의 this인 Array.prototpye의 자리를 apply메소드를 이용해서 가로채면 비 array객체도 객체 메소드를 활용할 수 있다.)

#브라우저 페이지 작업 처리 과정
- DOM,CSSOM 생성 - 렌더링 트리 - 레이아웃 - 페인트
- HTML LOAD -> HTML Parse :html파일을 한줄씩 해석 -> css링크 코드를 만나면 css파일 요청 (script 태그에서 js를 만나면 js파일 요청)-> css 파싱 -> 다시 html 파일로 돌아가서 해석을 마침 -> 해석을 기억하려고 문자열을 일종의 도식으로 표현함(DOM Tree) -> html과 css의 트리를 모아 렌더링 트리 완성 -> 렌더링 트리의 위치와 크기값을 결정할 레이아웃 설정 -> 실제 적용(페인트 단계)

##가장 최적의 렌더링 경로를 파악할 수 있는 방법 
구글의 Navigation Timing API을 활용한 시간 체크.

#크롬 개발자도구 알아보기
commandlinefanatic.com 

- [엘리먼트] - styles에 있는 element.style
인라인 속성으로 스타일 꾸미면 이 항목에 어떤 스타일로 꾸몄는지
그 항목이 나타난다.

- [프로퍼티]
모든 html 요소(element)는 오브젝트다. 그래서 각 요소/태그마다 프로퍼티가 있고, 부모 클래스를 가진다. 부모 클래스가 있다는 말은 부모 클래스와 자식 클래스 간의 상속이 존재한다는 뜻이기도 하다.

만약 body태그의 상속 단계를 알고 싶다면, 크롬 개발자 도구로 확인이 가능하다. 프로퍼티즈 탭을 클릭하면 body - HTMLBodyelement -  HTMLelement - Element - Node - EventTarget - Object
순으로 리스트가 배열되어있는 것을 알 수 있는데, 이 순서가 바로 html요소의 상속단계다.
 
제이쿼리에서 흔히 사용하는 addEventListener 메소드는 이벤트 타겟 클래스에 있는 프로퍼티. innerHTML의 경우는 HTMLelement 클래스에 있는 프로퍼티.

- 스타일 상속 확인 시 주의점
특정 요소가 어떤 스타일 가지고 있는지 확인할 때, 상위 요소에게 받은 속성이 있다. 그 중에서 적용이 안 된 속성은 투명한 회색으로 처리가 되는데, 이 때 회색으로 처리된 속성이 특정 요소에만 적용이 안 됐다는 표시일 뿐 그 상위 요소까지 적용이 안 됐다는 말로 받아들이면 안 된다.

#자바스크립트 활용
HTML DOM과 CSSOM의 노드를 삭제,추가,스타일링 하는 등 구조 전체를 컨트롤할 수 있다.

.style 프로퍼티 위치 : HTMLelement클래스
점(.)을 찍는다고 해서 메소드가 아니다. 메소드냐 아니냐 상관없이 어떤 객체의 프로퍼티에 접근할 때 점(.)을 쓸 뿐이다.


##window객체
웹브라우저 프로그램을 통괄하는 window객체. 이 객체 안에 브라우저 안에서 표시되는 웹사이트와 관련된 document객체가 있다.

#HTML에 CSS가 적용될 수 있는 이유
HTMLElement에 있는 스타일 프로퍼티(HTMLElement.style)가 사용되면서,CSSStyleDeclaration객체를 반환하는데 이 객체 안에 css의 속성/값들이 모두 존재한다. 이 객체는 읽기 전용이기 때문에 요소.style = "color : blue";와 같은 동적 할당 방식은 허용되지 않는다. .style.color= blue; 처럼 스타일 뒤에 스타일 프로퍼티 항목을 추가하고 값을 할당해야 된다. 

The HTMLElement.style property is used to get as well as set the inline style of an element. While getting, it returns a CSSStyleDeclaration object that contains a list of all styles properties for that element with values assigned for the attributes that are defined in the element's inline style attribute. 

단, style프로퍼티는 css를 태그-인라인 속성으로 적용할 때만 사용될 수 있다. css를 외부 링크나  <head>태그 안에 선언 방식으로 적용할 때는 window.getComputedStyle()를 사용해야한다. 이 메소드를 사용하면 CSSStyleDeclaration 객체가 만들어지고, 특정 요소에 원하는 스타일을 적용할 수 있게 된다.

##실행 컨텍스트 생성과정
엔진이 자바스크립트 파일을 읽기 시작하면 우선 전역 컨텍스트가 생성된다. 이 안에 코드에 저장된 변수,매개변수, 함수 등이 분류되서 저장되기 시작하고 함수 호출에 따라 추가적인 실행 컨텍스트가 전역 컨텍스트 위로 쌓이기 시작한다. 전역 컨텍스트가 만들어진 뒤, 가장 먼저 '활성' 객체가 생성된다. 이 안에 arguments객체나 사용자가 정의한 객체들이 저장되고(그래서 arguments객체는 전역 컨텍스트에서 찾을 수 없다), 객체 중 어떤 것이 실행되면 그 실행된 객체의 컨텍스트에 접근할 수 있는 기점이 된다. 

arguments객체를 저장하고 나면, [[scope]]프로퍼티가 생성되서 나중에 이 프로퍼티를 근거로 상위 컨텍스트에서 필요한 변수를 찾게 된다. 스코프가 마련이 되면, 지역 범위에 해당하는 객체들을 변수객체에 저장한다. 여기서 변수객체가 활성객체와 똑같은 의미로 쓰일 때가 있는데, 이는 지역 범위에 선언된 객체가 없고 모든 객체가 전역이라 활성객체에 저장될 때나 유효하다. 저장 과정이 끝나면 마지막으로 this바인딩을 한다.

#스코프와 클로저
##스코프란?
스코프는 유효범위로 변수가 어디까지 유효한지를 나타낸다.
자바스크립트의 스코프는 함수가 가진 중괄호를 기준으로 범위가 결정되었으나, ES6가 나오면서 블록 단위의 범위가 이뤄졌다.

##스코프는 어떻게 생성될까?
'렉시컬 스코프'라는 규칙 하에 객체가 정의된 시점을 기준으로 변수와 함수의 범위를 정한다. 그래서 전역 위치에 정의된 함수를 다른 함수 안에서 호출해도 그 함수의 스코프는 전역과 자신 두 가지를 가진다.
만약 함수 정의가 특정 함수 안에 있다면 함수의 스코프는 전역과 상위 함수 그리고 자신이 된다.

##클로저
함수가 실행이 되고 나면 그 함수가 가진 범위는 영향력을 잃고 사라진다. 다만 함수 몸체의 마지막 코드에서 함수가 가졌던 객체를 리턴값을 남긴다면 혹은 매개변수로 함수 안의 함수에 접근할 수 있다면,그 객체는 기본값이 복사되는 것처럼 함수가 사라져도 참조값을 그대로 가지고 있다. 이렇게 되면 외부에서 객체가 참조된 객체를 호출해도 에러없이 그 객체를 접할 수 있게 된다. 이를 클로저라 한다.

함수의 실행이 끝나기 전이나 가장 최근 호출된 함수가 계속 사용될 경우,즉 함수가 자신의 상위 Execution Context를 참조하고 있는 동안에는 Execution Context는 절대로 파기되지 않는다. 바로 이 점을 이용해 자바스크립트에서 Closure라는 기법을 사용할 수 있게 된다.