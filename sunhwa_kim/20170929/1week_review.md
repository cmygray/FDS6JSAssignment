
### 구문(statement)
- 실행시키는 각각의 명령
- 값, 연산자, 표현식, 키워드, 주석으로 구성되는 명령 집합.
- 구문은 코드블록(){구문;}으로 그룹화: 함께 실행되어야함을 정의


### 표현식
- 값, 변수, 연산자의 조합
- 연산을 통해 하나의 값으로 평가될 수 있는 문장

### 변수
- 값을 할당, 참조하기 위해 사용
- 변수명: 메모리에 할당된 공간을 가리키는 식별자

### 연산자
- 하나 혹은 그 이상의 값을 하나의 값으로 만들때 사용

### 키워드
- 수행할 동작을 규정한 것 (var, function...)


### 주석
- 작성된 코드의 의미를 설명하기 위해 사용



# Data type (자료형)
- 기본자료형 6개 + 객체형 1개 = 총 7개

## 기본자료형 (primitive data type)
- 변경 불가능한 값 (immutable value)
- Pass-by-value: 값에 의한 전달 (재할당 시, 해당 값을 복사)
```javascript
var num = 10;
var x = num;
// 이때 x는 num의 값을 복사하여 새로운 메모리 공간에 할당
```
1. Boolean: true, false
2. null: 의도적으로 변수값이 없음을 나타냄 (false로 취급)
3. undefined: 값을 할당하지 않은 변수의 값 (false로 취급)
4. Number: 정수, 실수, 음의 정수, infinity, NaN
5. String: '', "" 로 사용하는 문자열
6. Symbel : ECMAScript 6에서 추가, 유일무이한 프로퍼티 키

## 객체형 (Objective data type)
- 참조형이라고도 불림
- 기본자료형을 제외한 나머지 값들 (배열, 함수, 정규표현식 등)


# 변수
- 앞 문자는 영문자, underscore, $ 로 시작해야함
- 이후 숫자 사용도 가능
- 대소문자 구별
- 문법적으로는 중복선언이 가능하나, 사용 비추천 (의도하지 않게 변수값을 변경할 수 있음)
- var키워드 생략을 허용하나, 전역변수가 됨으로 사용 비추천
- 동적 타이핑: undefined, object, number, String등 여러 데이터 타입을 가질 수 있음
- Function-level scope


## 변수 호이스팅
*변수의 3단계 생성과정*
1. 선언 단계
2. 초기화 단계
3. 할당 단계
- 변수는 선언단계와 초기화단계가 한번에 이루어짐
- 스코프에 변수를 등록 > 메모리에 공간을 확보 > 'undefined'로 값을 초기화
- 변수를 할당해야만, 3단계 할당 단계가 진행
- 즉, 선언하지 않은 변수의 값을 출력하면 'undefined'값을 반환 (JS 특징)


# 5. 연산자
##  산술연산자
1. 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지, 증가(++), 감소(--)
2. 증가, 감소 연산자의 위치에 따른 연산방법
  - ++ : 선대입후증가 (z = x++;) / 선증가후대입 (z = ++x;)
  - -- : 선대입후감소 (z = x--;) / 선감소후대입 (z = --x;)
3. '+'연산자는 좌항 or 우항에 문자열이 있을 시, 문자열로 더함

## 대입연산자
- = : 우항값을 좌항에 대입함 (수학의 '같다'와 다름)
- 단축표기법 (ex: x += y ----> x = x + y)

## 비교연산자
- 반환값의 타입이 Boolean

1. == 과 === 의 차이
  1. == (동등비교, loose equality)
    - 자료의 타입을 강제변환하여 비교함
    - 최대한 true 값을 가지고자 함

  2. === (일치비교, strict equality)
    -  자료의 타입까지 일치해야 true

2. ? (삼항연산자, ternary operator)
  - 조건문처럼, 조건이 true일때 반환할 값과 false일때 반환할 값 설정 가능

## 논리연산자
  1. || (or, 논리 합 연산자)
    - 둘 중 하나의 값이 true라면 true


  2. && (and, 논리 곱 연산자)
    - 둘 다 true여야만 true

  3. ! (not, 논리 부정 연산자)
    - 빈문자열이 아닌 이상 true로 간주


## 단축 평가(Short-Circuit Evaluation)
  - 논리연산자가 boolean값과 함꼐 사용되지 않을 경우
  - && : 반드시 뒤의 값까지 봐야 하는 경우
  - || : 앞의 값만으로도 검사에 지장이 없는 경우
    ```javascript
    (true || anything) // true
    (false || anything) // anything
    (true && anything) // anything
    (false && anything) // false
    ```
## 타입 연산자(Type-Operators)
  - `typeof [sth]` 피연산자의 데이터 타입을 문자열로 반환
  - `instanceof [sth]` 객체가 동일 객체형의 인스턴스이면 `true` 반환


## !!
- 피연산자를 Boolean값으로 변환
- 객체의 존재를 확인할때도 유용하게 쓰임
```javascript
var obj;
console.log(!!obj); // false

obj = {};
console.log(!!obj); // true
```

# 제어문
## 블록구문
  - 불록구문: 구문들의 집합
  - 함수, 객체리터럴, 흐름제어구문 등에서 사용
  - {} 중괄호 사이를 블록구문이라고 함.
## 조건문
  1. if문
  ```javascript
  if (조건식A) {
    // 조건식A가 참이면 이 코드블록이 실행
  } else if (조건식B) {
    // 조건식A가 거짓이고 조건식B가 참이면 이 코드블록이 실행
  } else {
    // 조건식A, B가 모두 거짓이면 이 코드블록이 실행
  }    
  ```
  2. switch문
  ```javascript
  // 선택형 조건일 경우 사용할 수 있음
  // 그러나 현업에서 거의 쓰이지 않음
  // break; 를 잊지 말되 마지막엔 생략가능
  var color = 'red';

  switch (color) {
    case 'yellow':
      console.log('yellow color');
      break;
    case 'red':
      console.log('red color');
      break;
    case 'blue':
      console.log('blue color');
      break;
    default:
      console.log('unknown color');
  }
  ```

## 반복문
  1. for문
  - for문은 그 실행순서가 중요
  - 초기문에서 사용된 변수는 전역변수로 처리(ES5 특징)
  - 모든 식은 선택사항임 (어떤식도 쓰지 않으면 무한루프)
  ```javascript
  for ([초기문]; [조건문]; [증감문]) {
    구문;
  }

  // 예시: 0부터 10미만의 모든 정수 출력
  for (var i = 0; i < 10; i++) {
    console.log(i);
  }  
  ```

  2. while문
  - 조건문이 참이면 코드블럭을 계속 반복실행
  - (조건문이 언제나 참일경우)무한루프를 탈출하기 위해 break 사용
  ```javascript
  // 예시: n이 3보다 작을 때까지 계속 반복
  while (n < 3) {
    n++;
    x += n;
    console.log(x);
  }
  ```

  3. do while문
  - while과 거의 비슷하나 조건문을 확인하기 전에 무조건 1회 실행
  ```javascript
  // 현업에서 거의 쓰이지 않는다.
  var i = 0;
  do {
    console.log(i);
    i++;
  } while (i < 3);
  ```

  4. continue
  - break문은 반복문 하나를 탈출하는 반면, continue는 이후 구문을 스킵 후, 반복문의 조건문으로 이동
  ```javascript
  for (var i = 0; i < 10; i++) {
    if (i % 2 == 0) continue;
    console.log(i);
  }
  ```

## 평가
  1. 암묵적 강제 형 변화
  - JavaScript에서는 조건식을 평가할 때 여러 환경의 문맥(context)을 고려하여 최대한 참/거짓의 `boolean`값으로 해석하려 노력한다. 이때 암묵적인 강제 형 변화가 발생
  - 이를 통해 조건식을 평가
  - 이때 의도하지 않은 값이 만들어질 수 있어 주의가 필요함
  3. Data type conversion
  - string -> number
  ```javascript
  var val = '123';

  val = +val; // unary "+" operator
  // val = val * 1;
  // val = parseInt(val);
  // (비추) val = Number(val);
  ```
  - number -> string
  ```javascript
  var val = 123;

  val = val + '';
  // val = val.toString();
  // (비추) val = String(val);
  ```
  4. Truthy & Falsy values
  - 긍정적인 느낌은 `true`, 부정적인 느낌은 `false`
  - `false`으로 간주되는 대표적인 (Falsy values)
    - `false`
    - `undefined`
    - `null`
    - `0`
    - `NaN`
    - `''` (빈 문자열)
  5. Checking equality
    - 타입까지 비교해주는 일치연산자(===, !===) 사용 권장
  6. Checking Existence
    - 객체나 배열(배열도 객체)이 값을 갖고 있다면 true로 간주
    - 요소의 존재 -> true, 존재하지 않음 -> false
    - 하지만 간주된다는 것이지 실제 boolean값 `true`와 같지 X


# 객체 (Object)
    1. pass by reference
      - 기본 자료 형은 값을 복사해서 새로운 참조값을 주지만, 객체는 같은 값을 가리키게 됨
      - 따라서 두개의 객체가 같은 값을 가리키고 있다면, 하나만 변경해도 연동됨
    2. 객체는 이러한 프로퍼티를 포함하는 컨테이너
    3. delete로 삭제 불가
     객체는 선언 이후 메모리에 올라감, 따라서 객체를 삭제하고 싶다면 객체명 ="null"로 *참조값* 을 삭제 가능
    - 그 이유는 values는 primitive data. 즉, immutable. 따라서 참조값을 삭제하고 기존의 value는 가비지 컬렉션을 통해 삭제됨

## Property
    - 프로퍼티는 name: value 로 이루어진 한쌍.

    - 프로퍼티 값은 *undefined 제외* 모든 값을 가질 수 있음
    - 동적 생성이 가능하다는 기반으로, 객체 자체에는 순서가 없음 (배열과 다름)
    - 이름 생성 시, '-' 사용 비추 (엔진이 연산자로 착각) 필요시 언더스코어_ 사용
    - 프로퍼티는 동적 생성, 삭제(delete)가 가능 (js특징)
    - 삭제는 프로퍼티에만 가능, 객체 자체에는 불가


## Method
    - property의 value가 data가 아닌 함수일 경우 메소드라 칭함
    - 즉, 객체 내부에 묶여있는 함수

## 객체 생성 방법
    1. 객체 리터럴 (사람의 편의성을 위해 만든 방법)
    2. new Object(); 생성자 함수 (기계가 해석하는 방법)
      - 리터럴을 써도 생성자 함수 방식으로 기계는 인식
    3. 생성자 함수
      - 객체를 만드는 함수 그 자체 (우리가 커스텀 가능)
      - 이렇게 생성된 객체를 '인스턴스'라고 부르기도 함


## for-in문
    - 객체에 포함된 프로퍼티에 루프 수행 (순회)가능
    - 객체말고 배열에는 사용하지 않도록 (순서 문제 발생 -> 배열은 배열의 요소를 순회하는 for-of문 사용)


# 함수
    - 매개변수(인자, parameter)설정의 중요성! -> 함수를 통해 재생산 하는 것의 포인트
    - 인수(argument)는 매개변수에 할당되는 값
    - 함수는 매개변수에 함수를 할당할 수 있음 (콜백함수)
    - 함수 선언식과 표현식의 차이점! (하단참조)
    - 인수에 primitive data / object 들어갈때 각 특성을 그대로 따름

## 함수 정의방법 3가지
    1. 함수선언식
      - 함수명 생략 불가 (없으면, 호출자체가 불가)
      - 실행 시, 엔진이 함수명과 동일한 변수명을 저장하여 해석(표현식으로 전환되서 해석)
      - 실행 1,2,3(생성/초기화/할당)단계가 한번에 이뤄짐

    2. 함수표현식
      - 기명함수 / 익명(무명)함수
      - 익명함수가 일반적

    3. function()생성자 함수
    - functino.prototype.constructor 프로퍼티로 접근 가능(*프로토타입 체이닝*)

### 반환값 (return)
    - 호출한 코드에게 수행한 결과를 반환
    - 여러개의 값을 반환 가능
    - return구문 생략 시 의미: return undifined; 로 취급

### argument property
    - 함수 호출시, 매개변수에 몇개 들어올지 모르는 상태에 *인수* 로써 의도적으로 사용
    - 들어오는 인수를 배열로 취급함에 따라 대괄호 호출법 사용 가능
      - arguments[0] : 인수로 들어온 0번째 인덱스


### length property
    - 함수 정의 시, 매개변수가 몇개인지 매개변수 갯수를 의미


## 즉시호출함수표현식 (IIFE)
    - 함수를 선언하자마자 호출문(); 바로 사용
    - 이를 표현하고자, function문 전체를 ()로 감싸줌
    - 단 *한번만* 호출가능
    - 지역변수만을 사용한다는 장점 (전체js를 내부에 넣어놓으면, 전체 코드를 전역변수없이 사용 가능)
    - 익명사용이 일반적

## 내부 함수
    - 지역함수: 스코프의 조절을 위해 사용

## 콜백 함수
    - 특정 이벤트가 발생했을 때, 시스템(브라우저)에 의해 호출 (이벤트 핸들러)
    - 즉, 개발자가 명시적으로 호출X, 브라우저에게 호출하라고 시킬 뿐



# 함수 프로토타입
    - 자바스크립트의 객체지향을 충족하기 위한 방식론
    - ES6에서는 클래스의 개념이 생겼음


    1. function Person
    - 객체를 생산하는 생성자함수 person
     - (그러나 자바스크립트 엔진은 뭘 생산할지 몰라서 객체를 생산하는 함수가 아닐지언정, 생성자함수로 취급하여 prototype을 가지고 있음)
     - 개발자들 사이에선 암묵적으로 생성자함수명은 대문자로 시작
    - prototype 프로퍼티를 갖고있음
    - person.prototype.constructor와 같은 실상=
    - 프로토타입 체이닝에 의해, me.constructor와도 같음  
    2. var me = new person() \__proto__
    - Person이라는 함수를 생성자함수로 삼아 생성된 일반객체의 부모의 역할을 함.  
    3. person.prototype
    - 객체를 생산하는 person이라는 함수가 생성됨으로써 생성되는 프로토타입
    - constructor 프로퍼티를 갖고잇음
    - me__proto__와 같은 실상

## 프로토타입 체인
    - 프로토타입 체인의 종점은 object.prototype
    - 객체 리터럴로 객체를 생성했을때는 상속관계의 단이 종점인 objec.prototype밖에 없어 여기에 메소드를 추가할 시 빌트인이 변경됨 (비추)
    - 즉, 객체 리터럴 본인외에 공통부분이 있어 효율상 상속관계가 필요하다면, 객체리터럴로 객체를 생성X -> 생성자함수로 생성
    - 그래야만 생성자함수.prototype으로 전체 빌트인을 변경하지 않고도 상속관계를 사용하여 메소드 사용이 가능  



# 스코프
    - 자바스크립트는 **함수 중괄호** 만을 지역으로 갖음 (Function-Level Scope)
    - 자바스크립트는 중복변수, 중복함수를 허용 -> 에러나지 않고 작동(의도하지 않은 값으로)
    - 따라서 전역스코프는 되도록 사용x

## 전역스코프 탈피 방법
    1. IIFE, 즉시호출함수 사용
    2. ES6에서 let, const 사용


## 전역변수
    - 웹 브라우저 내 전역변수는 전역객체 window의 프로퍼티
    - 노드 환경 내 전역변수는 전역객체 global의 프로퍼티
    - 암묵적전역
        - 함수 내에 var를 선언하지 않고 변수A를 선언했을때 함수 내에도 A가 없고, 전역에서도 변수A가 없을때, 엔진은 함수 내의 변수A를 전역변수화 시킴
        - use strict모드일때는 전역변수화X -> 에러



# This
    1. 함수에서만 사용 가능
    2. 함수가 어떻게 호출되느냐에 따라 this가 지칭하는것이 달라짐 (자바스크립트 특징)
    3. this의 지칭객체 기본값은 window.
      - 예) 메소드 내부에 있는 함수는 일반함수 -> 여기서의 this는 window
    4. 메소드와 생성자함수에 있을때만 this가 지칭하는 것이 다름

## 메소드 호출 패턴
    - 메소드에 있는 this는 해당 메소드를 **소유한 객체**


## 생성자함수 호출 패턴
    - 생성자함수에 있는 this는 생성자함수가 new연산자를 통해 **생성될 인스턴스를 지칭**


#### [주의사항]
    **일반함수와 생성자함수 형식적차이X, new 연산자를 붙여서 호출할 시, 해당함수는 생성자함수로 동작**

    - new연산자 없이 함수를 호출 -> 생성자함수가 아니고 일반함수로 취급됨으로 this는 전역객체(window)
    - 이에 오해발생을 줄이기위해 **생성자함수명은 대문자** 로 시작하는것을 관행으로 함



## apply메소드 호출패턴
    - this가 지칭하는 객체를 내가 원하는 특정 객체로 바꾸고 싶을때 사용
