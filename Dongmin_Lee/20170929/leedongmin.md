# Data type & Variable - 자료형과 변수

변수 = 위치 기억 저장소
위치 = 메모리상의 주소
변수란 메모리주소에 접근하기 위해 사람이 지정한 식별자

- 자바 스크립트는 변수의 값이 할당 되는 과정에서 자동으로 자료형 결정
 즉 기입한값에 자동으로 메모리 할당 및 같은 변수에 여러 자료형 값 대입 가능 하다

## 1. DATA Type(자료형)

-기본자료형
 - Boolean: true & false *null, undefined, 0- false
 
- null: 변수와 메모리 어드레스의 참조 정보 제거시 사용 참조 제거 후 가비지콜랙션 수행

 -undefined: 값을 할당하지 않은 변수

 -Number: 숫자. * +/- Infinity 와 NaN도 숫자형

 -String: 문자열 - “ “ 사이 안에 작성 된 텍스트 / 변경 불가능 하다

 -Symbol: ES6에 추가됨, 프로퍼티 키로 사용됨

- 객체형
 - Object

## 2. 변수
- 변수는 유지할 필요가 있는 값의 경우에 사용한다
- 변수의 목적을 쉽게 이해할 수 있도록 의미있는 이름을 지정하여야 한다
 - 명명 규칙
   -영문자 / 특수문자 제외 / underscore (_), $ 기호로 시작해야함
   - 이어 지는 문제에 숫자 사용 가능
- 변수는 중복 선언 가능하나 사용하지 말자
- 변수 선언 시 var 키워드 생략 가능
 - 의도치 않게 변수를 전역화할 수 있으니 사용하지 말자
- 동적 타이핑: 같은 변수에 여러 자료형 값 대입 가능

* 변수호이스팅
- 코드 실행전var 선언문 또는 function 선언문을 해당 Scope 선두로 옮기는것
- var 키워드로 선언된 변수는 선언과 초기화가 한번에 이뤄진다.
- 즉 undefined 상태

### var 키워드로 선언된 변수의 문제점

1. for문의 변수는 전역변수
2. Var 키원드 생략 허용 - 의도치 않은 변수 전역화
3. 중복 선언 허용 - 의도치 않은 변수값 변경
4. 변수 선언전 참조 가능 - 호이스팅
*전역 변수로 인한 문제 발생 주의
# 연산자
## 산술 연산자
+ 덧셈 / - 뺄샘 / * 곱셈 / /나눗셈 / % 나머지 / ++ 증가 / — 감소

## 대입 연산자
= : x = y
+=: x= x + y
-+: x = x - y
*=: x =x * y
/=: x = x / y
%=: x = x % y

## 비교 연산자
= = : 동등비교  / 형변환 후 비교
= = =: 일치 비교 / 타입까지 일치하여야 true반환
!=: 부등비교
!==: 불일치비교
>, <, >=, <= : 관계비교
?: 삼항 연산자

## 논리 연산자
||: or
&&: and
!: not

## 단축 평가
True || anything —> true
False || anything —> anything
True && anything —> anything
False && anything —> false

## 타입 연산자
Typeof :  데이터 타입을 문자열로 반환
Instance of: 객체가 동일 객체형의 인스턴스면 true 반환

## !!
피연산자를 불린값으로 변환


#  Control Flow - 제어문
##블록구문
- 구문들의 집합, 중괄호로 범위를 정한다 { }
- 함수, 객체 리터럴, 흐름 제어구문에 사용

##조건문
-조건에 따라 다음 코드를 진행 시키는 것
- 의사결정 기준 제시, 그 결과에 따른 행위 지시
- 조건식이 참인지 거짓인지에 따라 실행될 구문의 집합
- if…else / switch

###if 문
- 조건식의 참 거짓에 따라 다음 코드가 실행 된다.
If (조건식) {
//조건식 참일 경우 실행
} else {
//조건식 거짓이면 실행
}

### switch 문
- switch 변수의 값과 일치하는 case문 부터 실행 하게 된다
- 일치하는 변수값이 없을 경우 default로 이동한다
- break 키워드로 switch 구문 탈출

##반복문
- 주어진 조건식이 ‘참’인 경우 코드 블록 실행, 실행 후 조건식 검토, 거짓이 될때 까지 실행

### for 문
- 특정 조건이 거짓이 될때까지 반복
‘’’
For ([초기문]; [조건문]; [증감문]){
	구문;
}
‘’’

###while문
- 조건문이 참이면 코드 블록을 반복 실행, 조건문이 거짓이 되면 실행 종료
- 조건문이 언제나 참이면 무한루프
- 무한루프 탈출을 위해 break문 사용

## 평가
- 조건식을 참, 거짓 평가 후 결과에 따라 실행한다
- 조건식은 일반적 표현식 뿐 아니라 리터럴값, 변수, 내장값등 또한 조건식 사용 가능

### 암묵적 강제 변환
- 자바스크립트는 내부적으로 자료형을 암묵적으로 강제 변환하여 작업을 한다.
- 의도치 않은 값을 만들어낼 수 있으니 주의

###문자를 숫자를 바꾸는 법
 - var x = ‘123’;  —> string
 * string 을 number로 변환
 - x = +x;
 - x = x * 1;             
 - x = Number(x);
 - x = parseInt(x); 

### 숫자를 문자로 바꾸는 법
- var y = 123;
 *number를 string로 변환
 - y = y + ‘’ ;
 - y = String(y);
 - y = y.toString();

### falsy 값
-  false
- undefined
- null
- 0
- NaN
- ‘ ‘ ( 빈문자열)

- 이외는 모두 true / truthy 값



# Object - 객체

## 객체란?
-속성
 - 일상생활에 인지하고 있는것들의 특징을 프로그램에 필요한 부분만을 데이터화 시킨것
 -ex) 사람- 속성: 이름 나이 성별 으로만 추상화해서 객체를 만든다
- 기본 자료형을 제외한 나머지 값들(함수, 배역, 정규표현식 등)은 모두 객체이다
- 객체는 데이터와 데이터의 동작을 모두 포함할 수 있다.
- 객체를 사용 하여 데이터를 구조화 하고, 자료구조를 쉽게 표현 가능하다.

## 프로퍼티와 메소드
- 프로퍼티 이름과 프로퍼티 값으로 구성 된다.
 - 프로퍼티 이름 : 빈 문자열을 포함하는 문자열과 숫자
 - 프로퍼티 값: undefined를 제외 한 모든 값

- 메소드는 객체 안에서만 작동하는 함수이다.
- 즉 프로퍼티 값이 함수인 경우 메소드라고 칭한다,

## 객체 생성 방법
1. 객체 리터럴
- 객체 변수를 선언하고 중괄호{} 안에 프로퍼티 이름 과 프로퍼티 값, 메소드를 기입하여 작성한다
```
var person = {
  name: 'Lee',
  gender: 'male',
  sayHello: function () {
    console.log('Hi! My name is ' + this.name);
  }
}
```
- 선언과 동시에 인스턴스가 생성 된다.

2. Object() 생성자 함수
- 해당 함수를 실행해서 객체를 생성하는 방법
- var person = new Objet() - 빈 객체 선언
- 이후 프로퍼티를 추가 할 수있다.
```var person = new Object();
person.name = 'Lee';
person.gender = 'male';
person.sayHello = function () {
  console.log('Hi! My name is ' + this.name);
};
```
** 자바스크립트 내부적으로 객체 리터럴 방식을 만나면 Object()함수를 자동으로 불러낸다
***객체 리터럴 방식이 더 간편하다.

3. 생성자 함수
- 프로퍼티 값만 다른 여러 객체를 생성시 사용
- Object() 생성자 함수와 달리 객체 안의 데이터가 채워진 객체를 생성할 수 있다
***This 는 생성자 함수르 사용해서 새로 생성시킬 객체를 의미 한다
- 값만 다른 여러 유사 객체를 생성시 사용될 기본 탬플릿을 의미한다
- 생성자 함수가 만들어낸 객체를 인스턴스라고 한다
- 함수 내부에서만 사용 가능한 변수를 선언 할 수 있다.
  - 이 변수는 지역 변수라서 함수 밖에서는 불러낼수 없다.
- this로 선언 된것은 함수 밖에서도 불러낼수 있다.
- 생성자 함수 이름은 대문자로 시작하여 작성하여 생성자 함수임을 인식한다
- 일반 함수에 new연산자를 붙여 호출하면 생성자 함수처럼 동작한다.
```
// 생성자 함수
function Person(name, gender) {
  this.name = name;
  this.gender = gender;
  this.sayHello = function(){
    console.log('Hi! My name is ' + this.name);
  };
}

// 인스턴스의 생성
var person1 = new Person('Lee', 'male');
var person2 = new Person('Kim', 'female');
```

##객체 프로퍼티 접근
1. 프로퍼티 이름
-프로퍼티 이름에 ‘-‘ 기호를 사용해야만 하는경우에는 반드시 ‘’따옴표로 감싸줘야한다
 -Ex- first-name  x —> ‘first-name’  o
     - 이때는 first_name 언더바르 사용 하거나 firstName(카멜 케이스)를 사용을 권유
**예약어를 프로퍼티 이름으로 사용 가능하나 사용하지 않을것을 추천

2. 프로퍼티 값 읽기
-마침표 표기법: 따옴표 안붙어 있는 프로퍼티 호출시
-대괄호 표기법: 따옴표를 사용한 프로퍼티 호출시
 - 대괄호 표기법 사용 시 대괄호 안에 따옴표포함 프로퍼티 이름 기입해야함
	- 따옴표 없을시 변수로 인식한다.

3. 프로퍼티 값 갱신
- 객체의 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 갱신된다.

4. 프로퍼티 동적 생성
-동적으로 프로퍼티를 추가 또는 수정 그리고 삭제 할 수 있다.

5. 프로퍼티 삭제
-삭제 할 시 delete연산자 사용 
	ex) delete 객체이름.프로퍼티 이름

6. For-in 문
- for-in문을 사용하여 모든 프로퍼티에 대해 루프를 수행할 수 있다.
- 하지만 For in 문을 배열에 사용시 반환되는 순서가 보장되지 않는다

## Pass-by-reference
- object는 참조형인바 객체의 모든 연산이 참조값으로 처리된다.
- 객체는 변경 가능한 프로퍼티의 집합이다.
- 객체가 생성 되면 값 자체를 저장하는것이 아니라 객체의 참조값 주소를 저장하고있다.
- a라는 변수에 객체를  생성한 뒤 b라는 변수에 a의 값을 할당하면 두개의 값이 가리키는 참조값 주소가 동일하다
- 이때 a === b true이다 / 이떄 참조 하는 객체의 값이 변경되면 a,b 변수의 객체가 참조하는 값도 동시에 변경된다.
- 하지만 다른 경우가 있다
A 객체를 생성해서 x: 10 이라는 프로퍼티를 생성
B 객체를 생성해서 x:10 이라는 프로피틀르 생성 후 
A === B  false가 된다. 이유는 둘이 참조하는 주소가 각각 상이하기 때문이다.

## Pass-by-value
- 기본자료형의 값은 변경불가하고, 값이 복사되어 전달된다. 

# 함수
- 어떤 특정 작업을 수행하기 위해 필요한 일련의 구문들을 그룹화하기 위한 개념이다.
- 동일 작업 반복 수행 해야 할 시 함수 재사용 가능하다
- 함수는 객체이지만 호출 할 수 있다는 특징이 있다.
- 함수는 일급객체이다. 변수, 객체, 배열에 저장 가능하고 인수로 사용 하며 함수의 반환값이 될 수도있다.

## 함수 정의 방식
1. 함수 선언식
Function 키워드로 선언 되면 함수명, 매개변수 목록, 함수 몸체로 구성되어있다.
1) 함수명: 함수 선언식에서 함수명은 반드시 기입해야한다. 호출 및 식별자 역할
2) 매개변수 목록: () 괄호 아네 0개 이상의 목록으로 구성된다. 자료형 체크 필요 할 수 있다
3) 함수 몸체: 함수가 호출 되었을 시 실행되는 구문들이다 {}중괄호로 감싸고 return문으로 결과값 반환한다.

2. 함수 표현식
함수 리터럴 방식으로 함수를 정의하고 변수에 할당 하는 방식
* 변수에 함수명 저장이 아닌 함수를 가리키는 참조값 저장한다(객체와 동일)
함수명을 생략 가능하고 이를 익명 함수라고 한다.
함수 표현식에서는 함수명 생략이 일반적임.
함수 호출시 변수명이 아닌 기명 함수의 함수명 사용시 에러 발생한다. 
-함수 선언식에서 함수명 호출이 가능한 이유는
함수 선언식으로 생성한 함수를 호출시 자바스크립트 엔진이 함수 표현식으로 형태 변경 하기 떄문이다
(이때 함수명이 변수명이 된다)

3. Function() 생성자 함수
함수 선언식과 함수표현식은 모두 내장 함수 Function() 생성자 함수로 함수를 생성화 시킨것을 단순화 시킨 것이다.
이 방법은 일반적으로 사용하지 않는다.

## 함수 호이스팅
- 변수 선언문과 같이 코드 실행시 함수를 해당 스코프 맨 위로 옮기는것을 말한다.
- 이때 함수 선언, 초기화, 할당이 한번에 이루어 진다
- 하지만 같은 경우 함수 표현식의 경우 변수 호이스팅이 발생해서 에러가 발생한다.
- 이러한 이유로 조금더 규칙에 적합한 함수 표현식 사용을 권장한다.

## 매개변수
-매개변수는 함수내에서 변수와 동일하게 동작한다.
-인수를 전달하지 않으면 매개변수는 undefined로 초기화 된다.

###call - by - value
- 기본 자료형인수는 변수의 그것 처럼 값이 복사 되어 전달 된다. 때문에 함수 내 매개변수를 통해 값이 변경되어도 
기본자료형 값은 변경되지 않는다.

### call- by -reference
객체형 인수도 객체와 마찬가지로 함수에 호출 될 시 복사 되지 않고, 참조값이 매개변수에 저장되어 전달 된다.
이는 함수 몸체에서 매개변수의 값이 변경되면 원본 객체도 변경되는 부수효과를 발생시킨다
이를 비순수 함수라고 한다.
이와 달리 기본자료형 인수는 값을 복사해서 전달하기 때문에  함수 몸체에서 매개변수의 값이 변경 되어도 원본 값이 유지되어 순수함수라고 한다. 

## 즉시 호출 함수 표현식 (IIFE , Immediately Invoke Function Expression)
함수 정의와 동시에 실행되는 함수, 최초 한번만 호출 가능, 초기화 처리등에 사용

#프로토타입과 객체 지향
자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다.
이러한 부모객체를 Prototype객체 라고 한다
자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 __Prototype__이라는 숨겨진 프로퍼티를 가진다

## [[prototype]] vs Prototype
[[Prototype]]
- 모든 객체 소유 프로퍼티
- 객체의 부모 역할을 하는 프로토타입 객체를 가리킴

Prototype
- 함수 객체만 가지고 있음
- 함수 객체가 생성자로 사용될 떄 이 함수를 통해 생성될 객체의 부모 역할을 하는 프로토타입 객체를 가리킴.

## constructor
객체의 입장에서 자신을 생성한 객체를 가리킴 
프로토타입 객체의 constructorsms 객체를 생성하는 생성자 함수 객체를 가리킨다.

## Prototype chain
자바스크립트는 프로퍼티나 메소드에 접근할 때, 객체 자신에게 프로퍼티나 메소드가 없다면, __Prototype__이 가르키는 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다

## 프로토타입 객체 확장
- 프로토타입 객체도 객체인바 프로퍼티 추가 삭제 가능하다.
- 추가 삭제 후 즉시 프로토타입에 반영 된다.
- 예를 들어 생성자 함수로 객체를 생성후 해당 함수의 프로토타입에 메소드를 추가하면
생성된 객체에 부모객체인 프로토타입의 메소드를 사용가능하다.

#Scope
스코프란 변수가 가지고 있는 참조 범위를 의미한다.

변수는 선언위치에 의해 스코프를 가지게 된다. 
- 전역 변수: 전역 스코프- 코드 전역에서 참조 가능
- 지역 변수: 지역 스코프- 그 지역(함수 내부)와 하부 지역에서만 참조 가능

## Global Scope
- 글로벌 영역에 선언한 변수 즉 전역변수를 뜻한다
- 이는 전역 객체 ‘window’의 프로퍼티이기도 하다
- 전역 변수 선언은 변수명의 중복 등 여러 문제를 발생기키므로 사용 억제 해야하낟.

## non block-level scope
- 자바스크립트는 block-level- scope를 사용하지 않으므로 코드블록 내에 선언된 변수라 해도 글로벌 스코프를 갖게되어 전역변수가 된다.

##Function scope
- 자바스크립트느 함수 내부에 선언된 매개변수와 변수는 지역 변수이다.

## 암묵적 전역
함수 내부에 변수를 선언할 때 var 키워드를 사용하지 않을시 이는 전역변수로 선언된다.

## Lexical scoping
- 자바스크립트는 함수가 선언된 시점에서의 유효범위를 갖는다.


#This
## 함수 호출 패턴
기본적으로 this는 전역 객체에 바인딩 된다. 내부함수나 콜백함수도 전역객체에 바인딩 된다

## 메소드 호출 패턴
함수가 객체의 프로퍼티이면(메소드이면) 메소드 호출 패턴으로 호출된다 메소드 내부의 this는 해당 메소드를 호출한객체에 바인딩 된다
프로토타입 객체에 추가한 메소드도 해당 프로토타입 객체에 바인딩 된다
```
function Person(name) {
  this.name = name;
}

Person.prototype.getName = function() {
  return this.name;
}

var me = new Person('Lee');
console.log(me.getName());

Person.prototype.name = 'Kim';
console.log(Person.prototype.getName());
```
## 생성자 호출 패턴
생성자 함수로 함수를 호출하게 되면(new연산자를 이용하여 함수를 호출하면) this는 생성자 함수가 호출할 인스턴스(객체)에 바인딩된다
생성자 함수는 따로 정해진 것이 아닌, new연산자를 사용하는 함수일 뿐인 것으로, new를 생략하면 기본적인 함수 호출 패턴을 따라 전역 객체에 바인딩 된다 이러한 사고를 막기 위해 Scope-Safe Constructor 패턴을 사용한다. 이러한 패턴은 대부분의 라이브러리에서 광범위하게 사용한다
##apply 호출 패턴
apply() 메소드를 이용하여 정해진 this 바인딩 규칙 이외에, 특정 객체에 명시적으로 바인딩 할 수 있다
함수명.apply(this에 바인딩할 객체명, [함수에 전달할 인자 배열]) 의 방식으로 사용한다










